# 生成计划：通用方程组工厂函数（支持按名字指定未知量并兼容 NLsolve）

## 1. 项目概述

创建一个通用的Julia工厂函数，能够处理输入函数参数有重叠或部分重叠的情况（如 `f(x,y)`, `g(y,z)`, `h(x,z)`），并返回一个统一的方程组函数，适用于数值求解库（如NLsolve）。

## 2. 核心功能需求（对齐当前仓库约定）

### 输入（更友好的方式，含扫描参数）
- 多个子方程及其未知量名映射，推荐使用名字（String 或 Symbol）而非纯数字索引。
- 每个子方程为 `(func, var_names)`，例如 `(f, (:x,:y))`，其中 `func` 的调用约定为 `func(x1, x2, ..., p1, p2, ...)`：先传入未知量，再传入参数。
- 工厂同时接受全局参数名列表 `param_names`（例如 `(:T, :mu)`），这些参数会在扫描中变化并以向量/NamedTuple 形式传入 `func` 的参数部分。
- 可选：允许直接传入数字索引以向后兼容，但优先使用名字以便与 NamedTuple / `solution_names` 协同工作。

### 输出与契约
- 返回in-place残差函数 `F!(res, X)`：首选，用于与 NLsolve 等数值库无缝集成。
- 同时导出辅助映射函数：`pack(::AbstractVector) -> NamedTuple` 和 `unpack(::NamedTuple) -> Vector`，用于将求解向量与命名域互相转换，便于 scanner 写 CSV 列名。
- 为方便 scanner 使用，可额外提供 `make_solver_wrapper(F!, names)`，返回 scanner 友好的闭包 `solver(params; init, options) -> NamedTuple`。

### 约束条件
- 支持参数重叠（子方程可共享变量）。
- 与方程类型无关（线性/非线性均可）。
- 对自动微分友好（不在 F! 中强制 Float64，尽量泛化类型）。

## 3. 实现方案

本节给出一个以变量名（Symbol 或 String）为输入的工厂函数设计草案，并同时产出 in-place 残差 `F!`、以及用于 scanner 的包装器。

### 3.1 API 概览

-- create_equation_system(funcs_with_vars...; global_vars=nothing, param_names=nothing)
  - 输入：若干 `(func, vars)`，其中 vars 是名字元组或索引元组。
  - 输出：`F`（非 in-place 版本，返回 Vector）、`names`（变量顺序）和 `pack/unpack` 映射函数。

-- create_equation_system_inplace(funcs_with_vars...; global_vars=nothing, param_names=nothing)
  - 输入同上。
  - 输出：`F!(res, X)`（in-place 残差函数），`names`，`pack/unpack`。

### 3.2 名称驱动的实现要点（伪代码）

```julia
function create_equation_system_inplace(funcs_with_vars...; global_vars=nothing)
    # 1) 收集或确定全局变量顺序（names）
    if global_vars === nothing
        seen = Symbol[]
        for (_, vars) in funcs_with_vars
            for v in vars
                push!(seen, Symbol(v))
            end
        end
        names = unique(seen)
    else
        names = [Symbol(v) for v in global_vars]
    end

    name_to_idx = Dict{Symbol,Int}(n => i for (i,n) in enumerate(names))

    # 参数名解析（全局参数）
    if param_names === nothing
        param_names = Symbol[]
    else
        param_names = [Symbol(p) for p in param_names]
    end
    param_to_idx = Dict{Symbol,Int}(p => i for (i,p) in enumerate(param_names))

    # 2) 预解析子方程的索引（未知量索引）
    parsed = [(func, [name_to_idx[Symbol(v)] for v in vars]) for (func, vars) in funcs_with_vars]

    # 3) in-place 原型残差：接受额外的 params（向量或 NamedTuple）
    function F_param!(res::AbstractVector, X::AbstractVector, params)
        @inbounds begin
            for (i,(func, idxs)) in enumerate(parsed)
                # 将 X 中的未知量和 params 传给 func；假定 func 的签名为 func(x..., p...)
                args_x = map(j -> X[j], idxs)
                # 将 params 转为位置向量（按 param_names 顺序）
                if length(param_names) == 0
                    res[i] = func(args_x...)
                else
                    par_vals = Tuple(getfield(params, n) for n in param_names)
                    res[i] = func(args_x..., par_vals...)
                end
            end
        end
        return res
    end

    # 为兼容 NLsolve 返回普通 F!(res, X) 的简单绑定器可以由调用方生成
    pack = X -> NamedTuple{Tuple(names)}(Tuple(X))
    unpack = nt -> collect(values(nt))

    return (F_param!, Tuple(names), Tuple(param_names), pack, unpack)
end
```

说明：为避免额外分配，可在内部使用手写的参数展开（当子方程参数个数固定且较小时）或提供可选的 StaticArrays 路径。

### 3.3 scanner 友好的包装器

提供 `make_solver_wrapper(F!, names; postprocess=nothing)`，返回闭包

```julia
solver = make_solver_wrapper(F!, names; postprocess=postprocess)
# 调用: solver(params; init, options) -> NamedTuple（字段与 names 一致）
```

包装器职责：调用 NLsolve（或其他求解器）得到 `result.zero`，将其用 `pack` 转为 NamedTuple，调用可选 `postprocess` 补充物理量（如 :Omega, :pressure），并返回最终 NamedTuple（同时包含 `:zero` 字段以向后兼容）。

### 3.4 支持可变扫描参数（例如 T, μ）

在相图扫描中，像温度 `T`、化学势 `μ` 这样的外部参数会在每个扫描点变化。我们不希望每次改变这些参数都重建方程工厂（开销或复杂度）。对此有几种可选方案：

方案 A — 每次用新参数重建工厂（简单但低效）
- 优点：实现简单、类型清晰。
- 缺点：在大规模扫描中频繁重建会带来分配与编译开销，不推荐。

方案 B — 工厂返回带参数的原型残差 `F_param!(res, X, params)`；scanner 在每次调用时用一个短生命周期闭包绑定当前参数并传给求解器（即每点创建一次小闭包）
- 优点：不需要重建解析逻辑，代码直观。
- 缺点：每点创建闭包有极小开销；对并发执行需要注意闭包捕获的参数安全性。

方案 C（推荐） — 工厂返回一个参数化残差 `F_param!(res, X, params)`，并额外提供一个轻量的参数持有器 + 绑定器：
- 创建一次 `params_ref = Ref(initial_params)` 或 `ParamHolder(initial_params)`（可变容器）。
- 通过 `bind_params(F_param!, params_ref)` 得到一个 NLsolve 兼容的 `F!(res, X)`，该函数在内部读取 `params_ref[]` 并调用 `F_param!`。
- 在扫描循环中，仅更新 `params_ref[] = new_params`（或修改 `ParamHolder` 字段），而无需重建工厂或闭包。

示例（伪代码）：

```julia
# 假设工厂返回 F_param!(res, X, params), names, pack, unpack
F_param!, names, pack, unpack = create_equation_system_inplace((f, (:x,:y)), ...)

# 创建可变参数容器
params_ref = Ref((T=0.5, mu=-1.2))

function bind_params(F_param!, params_ref)
    return function (res, X)
        return F_param!(res, X, params_ref[])
    end
end

# 绑定一次，复用 F_bound 在扫描中
F_bound! = bind_params(F_param!, params_ref)

# 扫描循环（伪代码）
for (T, mu) in scan_grid
    params_ref[] = (T=T, mu=mu)
    result = nlsolve(F_bound!, initial_guess)
    nt = pack(result.zero)
    # postprocess/写 CSV
end
```

优点小结：
- 性能：只做一次工厂解析；更新参数只是对 `Ref[]` 的写入，开销极小。对内存/编译友好。
- 并发：如果并行扫描（多线程/多进程），为每个线程创建独立的 `params_ref`（或使用线程安全容器）；禁止共享同一 `params_ref` 并交叉写入。
- AD 兼容：保证 `F_param!` 对 `params` 的类型稳定（避免在扫描过程中改变 params 的类型），并且 `F_bound!` 不在签名上强化类型，以便 ForwardDiff 可工作。

错误模式与限制：
- 如果不同扫描点 `params` 的类型不同（如有时是 Float64，有时是 Int），AD/编译会导致方法特化，影响性能；建议保持参数类型一致。 
- 若需要在 solver 内部将参数视为常量以做额外预计算，可在 `bind_params` 时对参数进行一次性派生并缓存到 `ParamHolder` 中。


## 4. 使用示例

### 4.1 定义函数
```julia
f(x, y) = x^2 + y^2 - 1      # 单位圆
g(y, z) = y - z              # 直线 y = z
h(x, z) = x + z - 2          # 平面 x + z = 2
```

### 4.2 创建方程组函数
```julia
# 普通版本
F = create_equation_system((f, (1,2)), (g, (2,3)), (h, (1,3)))

```julia
# 使用名字指定未知量（推荐）
F!, names, pack, unpack = create_equation_system_inplace((f, (:x,:y)), (g, (:y,:z)), (h, (:x,:z)))

# names == (:x, :y, :z) 或者按出现顺序确定的全局变量顺序

# 将结果向量转为命名元组，方便后续 postprocess / 写 CSV
# result.zero 为求解器原始向量（保留以向后兼容）
nt = pack(result.zero)
println(nt.x, nt.y, nt.z)
```
# 测试点 [x, y, z] = [0.6, 0.8, 0.8]
result = F([0.6, 0.8, 0.8])
println(result)  # 输出: [0.0, 0.0, -0.6]
```

### 4.4 与NLsolve集成
```julia
using NLsolve

# 初始猜测
initial_guess = [0.5, 0.5, 0.5]

# 求解方程组
result = nlsolve(F!, initial_guess)

println("解为: x = $(result.zero[1]), y = $(result.zero[2]), z = $(result.zero[3])")
```

## 5. 扩展考虑

### 5.1 错误处理
- 验证索引是否在变量向量范围内
- 检查函数参数数量与索引元组长度是否匹配

此外应当处理并报告以下情况：
- 名称未在全局变量表中找到（报错并指出缺失名）
- 名称与数字索引用法混合时，明确优先级与转换规则（建议：名字优先，数字仅作兼容）
- 子方程在运行时抛异常：工厂函数应包装调用并在残差函数中转换为 NaN 或抛出更有信息的异常，以便 scanner 能捕获并记录 failed_points。

### 5.2 性能优化
- 预分配参数数组以避免重复分配
- 考虑使用静态数组提高性能

### 5.3 接口扩展
- 支持符号变量名映射（而不仅仅是数字索引）
- 添加自动微分支持

### 5.4 自动微分注意事项
- `F!` 应对不同数值类型泛化（不要假设 X 的元素是 Float64），以便 ForwardDiff / ReverseDiff 等 AD 库可以工作。
- 对于需要高性能的场景，提供一个非分配版并在文档中说明 AD 的限制与使用建议（例如，AD 时使用非 in-place 版本更安全）。

## 6. 测试计划

### 6.1 单元测试
- 测试参数无重叠的情况
- 测试参数部分重叠的情况
- 测试参数完全重叠的情况
- 测试错误输入的处理

另外要增加：
- 测试名字与数字索引混合的解析行为
- 测试 `pack/unpack` 的正确性（包括字段顺序）
- 测试 `F!` 在 ForwardDiff 下是否能被微分（类型泛化测试）

### 6.2 集成测试
- 与NLsolve集成测试
- 性能基准测试

集成测试还应覆盖：
- 与 scanner 集成：使用 `make_solver_wrapper` 生成的闭包传入 `scan_phase_space`，并断言 CSV header 包含 `names` 中的字段。
- 故障路径：当子方程返回 NaN 或 solver 失败时，scanner 是否按策略记录并填充。

## 7. 文档计划

### 7.1 函数文档
- 详细的docstring说明
- 使用示例和注意事项

### 7.2 示例代码
- 提供多种使用场景的示例
- 包含常见问题解决方案

## 8. 时间安排

1. 第1天：实现核心功能
2. 第2天：添加错误处理和测试
3. 第3天：性能优化和文档编写
4. 第4天：集成测试和示例代码

## 9. 风险评估与缓解

### 风险1：性能问题
- 缓解：提供in-place版本，考虑使用预分配

### 风险2：接口复杂性
- 缓解：提供清晰的文档和示例

### 风险3：与求解器兼容性
- 缓解：设计为通用接口，与具体求解器解耦

## 10. 成功标准

1. 能够正确处理参数重叠的函数
2. 与NLsolve等常用求解器良好集成
3. 性能可接受（无明显性能损失）
4. 接口直观易用
5. 有完整的文档和测试覆盖

补充成功标准（与仓库约定对齐）:
6. 支持按名字指定未知量并能将求解结果映射为 NamedTuple（用于 scanner 写 CSV 列名）。
7. 提供 `make_solver_wrapper` 或等价适配器，产生 scanner 可直接调用且返回 NamedTuple 的闭包。

## 下一步（建议的实现优先级）
1. 在 `src/core/` 实现 `create_equation_system_inplace`（支持名字/索引输入）和 `pack/unpack`。保证 `F!` 泛化类型以兼容 AD。
2. 实现 `make_solver_wrapper(F!, names; postprocess=nothing)`：调用 NLsolve，并返回 NamedTuple（包含 `:zero` 字段）。
3. 更新 `test/test_phase_scan_e2e.jl`：使用 `make_solver_wrapper` 或直接通过 `create_equation_system` 的 `pack` 来验证 `solution_names` 的传播和 CSV header。
4. 增加单元/集成测试并运行 smoke 测试，检查输出 CSV header 与 sample 数据。

如果你同意，我可以现在实现第1和第2步并运行相关 smoke 测试。

此计划提供了一个完整的实施方案，从核心功能到测试和文档，确保工厂函数能够满足处理参数重叠函数的需求。